// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "percolator_in.hxx"

namespace percolatorInNs
{
  // probability_t
  //

  probability_t::
  probability_t (const char* s)
  : ::xml_schema::string (s)
  {
  }

  probability_t::
  probability_t (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  probability_t::
  probability_t (const probability_t& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // aa_seq_t
  // 


  // aa_term_t
  // 


  // peptideType
  // 

  const peptideType::peptideSequence_type& peptideType::
  peptideSequence () const
  {
    return this->peptideSequence_.get ();
  }

  peptideType::peptideSequence_type& peptideType::
  peptideSequence ()
  {
    return this->peptideSequence_.get ();
  }

  void peptideType::
  peptideSequence (const peptideSequence_type& x)
  {
    this->peptideSequence_.set (x);
  }

  void peptideType::
  peptideSequence (::std::auto_ptr< peptideSequence_type > x)
  {
    this->peptideSequence_.set (x);
  }

  const peptideType::modification_sequence& peptideType::
  modification () const
  {
    return this->modification_;
  }

  peptideType::modification_sequence& peptideType::
  modification ()
  {
    return this->modification_;
  }

  void peptideType::
  modification (const modification_sequence& s)
  {
    this->modification_ = s;
  }


  // modificationType
  // 

  const modificationType::uniMod_type& modificationType::
  uniMod () const
  {
    return this->uniMod_.get ();
  }

  modificationType::uniMod_type& modificationType::
  uniMod ()
  {
    return this->uniMod_.get ();
  }

  void modificationType::
  uniMod (const uniMod_type& x)
  {
    this->uniMod_.set (x);
  }

  void modificationType::
  uniMod (::std::auto_ptr< uniMod_type > x)
  {
    this->uniMod_.set (x);
  }

  const modificationType::location_type& modificationType::
  location () const
  {
    return this->location_.get ();
  }

  modificationType::location_type& modificationType::
  location ()
  {
    return this->location_.get ();
  }

  void modificationType::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  const modificationType::residues_optional& modificationType::
  residues () const
  {
    return this->residues_;
  }

  modificationType::residues_optional& modificationType::
  residues ()
  {
    return this->residues_;
  }

  void modificationType::
  residues (const residues_type& x)
  {
    this->residues_.set (x);
  }

  void modificationType::
  residues (const residues_optional& x)
  {
    this->residues_ = x;
  }

  void modificationType::
  residues (::std::auto_ptr< residues_type > x)
  {
    this->residues_.set (x);
  }

  const modificationType::avgMassDelta_optional& modificationType::
  avgMassDelta () const
  {
    return this->avgMassDelta_;
  }

  modificationType::avgMassDelta_optional& modificationType::
  avgMassDelta ()
  {
    return this->avgMassDelta_;
  }

  void modificationType::
  avgMassDelta (const avgMassDelta_type& x)
  {
    this->avgMassDelta_.set (x);
  }

  void modificationType::
  avgMassDelta (const avgMassDelta_optional& x)
  {
    this->avgMassDelta_ = x;
  }

  const modificationType::monoisotopicMassDelta_optional& modificationType::
  monoisotopicMassDelta () const
  {
    return this->monoisotopicMassDelta_;
  }

  modificationType::monoisotopicMassDelta_optional& modificationType::
  monoisotopicMassDelta ()
  {
    return this->monoisotopicMassDelta_;
  }

  void modificationType::
  monoisotopicMassDelta (const monoisotopicMassDelta_type& x)
  {
    this->monoisotopicMassDelta_.set (x);
  }

  void modificationType::
  monoisotopicMassDelta (const monoisotopicMassDelta_optional& x)
  {
    this->monoisotopicMassDelta_ = x;
  }


  // experiment
  // 

  const experiment::freeTextInformation_sequence& experiment::
  freeTextInformation () const
  {
    return this->freeTextInformation_;
  }

  experiment::freeTextInformation_sequence& experiment::
  freeTextInformation ()
  {
    return this->freeTextInformation_;
  }

  void experiment::
  freeTextInformation (const freeTextInformation_sequence& s)
  {
    this->freeTextInformation_ = s;
  }

  const experiment::enzyme_type& experiment::
  enzyme () const
  {
    return this->enzyme_.get ();
  }

  experiment::enzyme_type& experiment::
  enzyme ()
  {
    return this->enzyme_.get ();
  }

  void experiment::
  enzyme (const enzyme_type& x)
  {
    this->enzyme_.set (x);
  }

  void experiment::
  enzyme (::std::auto_ptr< enzyme_type > x)
  {
    this->enzyme_.set (x);
  }

  const experiment::calibration_optional& experiment::
  calibration () const
  {
    return this->calibration_;
  }

  experiment::calibration_optional& experiment::
  calibration ()
  {
    return this->calibration_;
  }

  void experiment::
  calibration (const calibration_type& x)
  {
    this->calibration_.set (x);
  }

  void experiment::
  calibration (const calibration_optional& x)
  {
    this->calibration_ = x;
  }

  void experiment::
  calibration (::std::auto_ptr< calibration_type > x)
  {
    this->calibration_.set (x);
  }

  const experiment::process_info_type& experiment::
  process_info () const
  {
    return this->process_info_.get ();
  }

  experiment::process_info_type& experiment::
  process_info ()
  {
    return this->process_info_.get ();
  }

  void experiment::
  process_info (const process_info_type& x)
  {
    this->process_info_.set (x);
  }

  void experiment::
  process_info (::std::auto_ptr< process_info_type > x)
  {
    this->process_info_.set (x);
  }

  const experiment::featureDescriptions_type& experiment::
  featureDescriptions () const
  {
    return this->featureDescriptions_.get ();
  }

  experiment::featureDescriptions_type& experiment::
  featureDescriptions ()
  {
    return this->featureDescriptions_.get ();
  }

  void experiment::
  featureDescriptions (const featureDescriptions_type& x)
  {
    this->featureDescriptions_.set (x);
  }

  void experiment::
  featureDescriptions (::std::auto_ptr< featureDescriptions_type > x)
  {
    this->featureDescriptions_.set (x);
  }

  const experiment::fragSpectrumScan_sequence& experiment::
  fragSpectrumScan () const
  {
    return this->fragSpectrumScan_;
  }

  experiment::fragSpectrumScan_sequence& experiment::
  fragSpectrumScan ()
  {
    return this->fragSpectrumScan_;
  }

  void experiment::
  fragSpectrumScan (const fragSpectrumScan_sequence& s)
  {
    this->fragSpectrumScan_ = s;
  }


  // probability_t_member
  // 

  probability_t_member::
  probability_t_member (::xml_schema::double_ v): ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (v)
  {
  }

  probability_t_member::
  probability_t_member (const probability_t_member& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (v, f, c)
  {
  }


  // probability_t_member1
  // 


  // uniMod
  // 

  const uniMod::accession_type& uniMod::
  accession () const
  {
    return this->accession_.get ();
  }

  uniMod::accession_type& uniMod::
  accession ()
  {
    return this->accession_.get ();
  }

  void uniMod::
  accession (const accession_type& x)
  {
    this->accession_.set (x);
  }

  const uniMod::name_optional& uniMod::
  name () const
  {
    return this->name_;
  }

  uniMod::name_optional& uniMod::
  name ()
  {
    return this->name_;
  }

  void uniMod::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void uniMod::
  name (const name_optional& x)
  {
    this->name_ = x;
  }

  void uniMod::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // freeTextInformation
  // 

  const freeTextInformation::name_type& freeTextInformation::
  name () const
  {
    return this->name_.get ();
  }

  freeTextInformation::name_type& freeTextInformation::
  name ()
  {
    return this->name_.get ();
  }

  void freeTextInformation::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void freeTextInformation::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const freeTextInformation::value_type& freeTextInformation::
  value () const
  {
    return this->value_.get ();
  }

  freeTextInformation::value_type& freeTextInformation::
  value ()
  {
    return this->value_.get ();
  }

  void freeTextInformation::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void freeTextInformation::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // calibration
  // 

  const calibration::calibrationParameter_sequence& calibration::
  calibrationParameter () const
  {
    return this->calibrationParameter_;
  }

  calibration::calibrationParameter_sequence& calibration::
  calibrationParameter ()
  {
    return this->calibrationParameter_;
  }

  void calibration::
  calibrationParameter (const calibrationParameter_sequence& s)
  {
    this->calibrationParameter_ = s;
  }

  const calibration::massType_type& calibration::
  massType () const
  {
    return this->massType_.get ();
  }

  calibration::massType_type& calibration::
  massType ()
  {
    return this->massType_.get ();
  }

  void calibration::
  massType (const massType_type& x)
  {
    this->massType_.set (x);
  }

  void calibration::
  massType (::std::auto_ptr< massType_type > x)
  {
    this->massType_.set (x);
  }


  // process_info
  // 

  const process_info::command_line_type& process_info::
  command_line () const
  {
    return this->command_line_.get ();
  }

  process_info::command_line_type& process_info::
  command_line ()
  {
    return this->command_line_.get ();
  }

  void process_info::
  command_line (const command_line_type& x)
  {
    this->command_line_.set (x);
  }

  void process_info::
  command_line (::std::auto_ptr< command_line_type > x)
  {
    this->command_line_.set (x);
  }


  // featureDescriptions
  // 

  const featureDescriptions::featureDescription_sequence& featureDescriptions::
  featureDescription () const
  {
    return this->featureDescription_;
  }

  featureDescriptions::featureDescription_sequence& featureDescriptions::
  featureDescription ()
  {
    return this->featureDescription_;
  }

  void featureDescriptions::
  featureDescription (const featureDescription_sequence& s)
  {
    this->featureDescription_ = s;
  }


  // fragSpectrumScan
  // 

  const fragSpectrumScan::peptideSpectrumMatch_sequence& fragSpectrumScan::
  peptideSpectrumMatch () const
  {
    return this->peptideSpectrumMatch_;
  }

  fragSpectrumScan::peptideSpectrumMatch_sequence& fragSpectrumScan::
  peptideSpectrumMatch ()
  {
    return this->peptideSpectrumMatch_;
  }

  void fragSpectrumScan::
  peptideSpectrumMatch (const peptideSpectrumMatch_sequence& s)
  {
    this->peptideSpectrumMatch_ = s;
  }

  const fragSpectrumScan::scanNumber_type& fragSpectrumScan::
  scanNumber () const
  {
    return this->scanNumber_.get ();
  }

  fragSpectrumScan::scanNumber_type& fragSpectrumScan::
  scanNumber ()
  {
    return this->scanNumber_.get ();
  }

  void fragSpectrumScan::
  scanNumber (const scanNumber_type& x)
  {
    this->scanNumber_.set (x);
  }

  const fragSpectrumScan::precision_optional& fragSpectrumScan::
  precision () const
  {
    return this->precision_;
  }

  fragSpectrumScan::precision_optional& fragSpectrumScan::
  precision ()
  {
    return this->precision_;
  }

  void fragSpectrumScan::
  precision (const precision_type& x)
  {
    this->precision_.set (x);
  }

  void fragSpectrumScan::
  precision (const precision_optional& x)
  {
    this->precision_ = x;
  }

  const fragSpectrumScan::experimentalMassToCharge_optional& fragSpectrumScan::
  experimentalMassToCharge () const
  {
    return this->experimentalMassToCharge_;
  }

  fragSpectrumScan::experimentalMassToCharge_optional& fragSpectrumScan::
  experimentalMassToCharge ()
  {
    return this->experimentalMassToCharge_;
  }

  void fragSpectrumScan::
  experimentalMassToCharge (const experimentalMassToCharge_type& x)
  {
    this->experimentalMassToCharge_.set (x);
  }

  void fragSpectrumScan::
  experimentalMassToCharge (const experimentalMassToCharge_optional& x)
  {
    this->experimentalMassToCharge_ = x;
  }

  const fragSpectrumScan::totalIonCurrent_optional& fragSpectrumScan::
  totalIonCurrent () const
  {
    return this->totalIonCurrent_;
  }

  fragSpectrumScan::totalIonCurrent_optional& fragSpectrumScan::
  totalIonCurrent ()
  {
    return this->totalIonCurrent_;
  }

  void fragSpectrumScan::
  totalIonCurrent (const totalIonCurrent_type& x)
  {
    this->totalIonCurrent_.set (x);
  }

  void fragSpectrumScan::
  totalIonCurrent (const totalIonCurrent_optional& x)
  {
    this->totalIonCurrent_ = x;
  }


  // calibrationParameter
  // 

  const calibrationParameter::name_type& calibrationParameter::
  name () const
  {
    return this->name_.get ();
  }

  calibrationParameter::name_type& calibrationParameter::
  name ()
  {
    return this->name_.get ();
  }

  void calibrationParameter::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void calibrationParameter::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const calibrationParameter::value_type& calibrationParameter::
  value () const
  {
    return this->value_.get ();
  }

  calibrationParameter::value_type& calibrationParameter::
  value ()
  {
    return this->value_.get ();
  }

  void calibrationParameter::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // massType
  // 

  massType::
  massType (value v)
  : ::xml_schema::token (_xsd_massType_literals_[v])
  {
  }

  massType::
  massType (const char* v)
  : ::xml_schema::token (v)
  {
  }

  massType::
  massType (const ::std::string& v)
  : ::xml_schema::token (v)
  {
  }

  massType::
  massType (const ::xml_schema::token& v)
  : ::xml_schema::token (v)
  {
  }

  massType::
  massType (const massType& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (v, f, c)
  {
  }

  massType& massType::
  operator= (value v)
  {
    static_cast< ::xml_schema::token& > (*this) = 
    ::xml_schema::token (_xsd_massType_literals_[v]);

    return *this;
  }


  // featureDescription
  // 

  const featureDescription::name_type& featureDescription::
  name () const
  {
    return this->name_.get ();
  }

  featureDescription::name_type& featureDescription::
  name ()
  {
    return this->name_.get ();
  }

  void featureDescription::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void featureDescription::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const featureDescription::description_optional& featureDescription::
  description () const
  {
    return this->description_;
  }

  featureDescription::description_optional& featureDescription::
  description ()
  {
    return this->description_;
  }

  void featureDescription::
  description (const description_type& x)
  {
    this->description_.set (x);
  }

  void featureDescription::
  description (const description_optional& x)
  {
    this->description_ = x;
  }

  void featureDescription::
  description (::std::auto_ptr< description_type > x)
  {
    this->description_.set (x);
  }


  // peptideSpectrumMatch
  // 

  const peptideSpectrumMatch::features_type& peptideSpectrumMatch::
  features () const
  {
    return this->features_.get ();
  }

  peptideSpectrumMatch::features_type& peptideSpectrumMatch::
  features ()
  {
    return this->features_.get ();
  }

  void peptideSpectrumMatch::
  features (const features_type& x)
  {
    this->features_.set (x);
  }

  void peptideSpectrumMatch::
  features (::std::auto_ptr< features_type > x)
  {
    this->features_.set (x);
  }

  const peptideSpectrumMatch::peptide_type& peptideSpectrumMatch::
  peptide () const
  {
    return this->peptide_.get ();
  }

  peptideSpectrumMatch::peptide_type& peptideSpectrumMatch::
  peptide ()
  {
    return this->peptide_.get ();
  }

  void peptideSpectrumMatch::
  peptide (const peptide_type& x)
  {
    this->peptide_.set (x);
  }

  void peptideSpectrumMatch::
  peptide (::std::auto_ptr< peptide_type > x)
  {
    this->peptide_.set (x);
  }

  const peptideSpectrumMatch::occurence_sequence& peptideSpectrumMatch::
  occurence () const
  {
    return this->occurence_;
  }

  peptideSpectrumMatch::occurence_sequence& peptideSpectrumMatch::
  occurence ()
  {
    return this->occurence_;
  }

  void peptideSpectrumMatch::
  occurence (const occurence_sequence& s)
  {
    this->occurence_ = s;
  }

  const peptideSpectrumMatch::id_type& peptideSpectrumMatch::
  id () const
  {
    return this->id_.get ();
  }

  peptideSpectrumMatch::id_type& peptideSpectrumMatch::
  id ()
  {
    return this->id_.get ();
  }

  void peptideSpectrumMatch::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void peptideSpectrumMatch::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const peptideSpectrumMatch::isDecoy_type& peptideSpectrumMatch::
  isDecoy () const
  {
    return this->isDecoy_.get ();
  }

  peptideSpectrumMatch::isDecoy_type& peptideSpectrumMatch::
  isDecoy ()
  {
    return this->isDecoy_.get ();
  }

  void peptideSpectrumMatch::
  isDecoy (const isDecoy_type& x)
  {
    this->isDecoy_.set (x);
  }

  const peptideSpectrumMatch::observedTime_optional& peptideSpectrumMatch::
  observedTime () const
  {
    return this->observedTime_;
  }

  peptideSpectrumMatch::observedTime_optional& peptideSpectrumMatch::
  observedTime ()
  {
    return this->observedTime_;
  }

  void peptideSpectrumMatch::
  observedTime (const observedTime_type& x)
  {
    this->observedTime_.set (x);
  }

  void peptideSpectrumMatch::
  observedTime (const observedTime_optional& x)
  {
    this->observedTime_ = x;
  }

  const peptideSpectrumMatch::experimentalMassToCharge_type& peptideSpectrumMatch::
  experimentalMassToCharge () const
  {
    return this->experimentalMassToCharge_.get ();
  }

  peptideSpectrumMatch::experimentalMassToCharge_type& peptideSpectrumMatch::
  experimentalMassToCharge ()
  {
    return this->experimentalMassToCharge_.get ();
  }

  void peptideSpectrumMatch::
  experimentalMassToCharge (const experimentalMassToCharge_type& x)
  {
    this->experimentalMassToCharge_.set (x);
  }

  const peptideSpectrumMatch::calculatedMassToCharge_type& peptideSpectrumMatch::
  calculatedMassToCharge () const
  {
    return this->calculatedMassToCharge_.get ();
  }

  peptideSpectrumMatch::calculatedMassToCharge_type& peptideSpectrumMatch::
  calculatedMassToCharge ()
  {
    return this->calculatedMassToCharge_.get ();
  }

  void peptideSpectrumMatch::
  calculatedMassToCharge (const calculatedMassToCharge_type& x)
  {
    this->calculatedMassToCharge_.set (x);
  }

  const peptideSpectrumMatch::chargeState_type& peptideSpectrumMatch::
  chargeState () const
  {
    return this->chargeState_.get ();
  }

  peptideSpectrumMatch::chargeState_type& peptideSpectrumMatch::
  chargeState ()
  {
    return this->chargeState_.get ();
  }

  void peptideSpectrumMatch::
  chargeState (const chargeState_type& x)
  {
    this->chargeState_.set (x);
  }


  // features
  // 

  const features::feature_sequence& features::
  feature () const
  {
    return this->feature_;
  }

  features::feature_sequence& features::
  feature ()
  {
    return this->feature_;
  }

  void features::
  feature (const feature_sequence& s)
  {
    this->feature_ = s;
  }


  // occurence
  // 

  const occurence::proteinId_type& occurence::
  proteinId () const
  {
    return this->proteinId_.get ();
  }

  occurence::proteinId_type& occurence::
  proteinId ()
  {
    return this->proteinId_.get ();
  }

  void occurence::
  proteinId (const proteinId_type& x)
  {
    this->proteinId_.set (x);
  }

  void occurence::
  proteinId (::std::auto_ptr< proteinId_type > x)
  {
    this->proteinId_.set (x);
  }

  const occurence::startPosition_optional& occurence::
  startPosition () const
  {
    return this->startPosition_;
  }

  occurence::startPosition_optional& occurence::
  startPosition ()
  {
    return this->startPosition_;
  }

  void occurence::
  startPosition (const startPosition_type& x)
  {
    this->startPosition_.set (x);
  }

  void occurence::
  startPosition (const startPosition_optional& x)
  {
    this->startPosition_ = x;
  }

  void occurence::
  startPosition (::std::auto_ptr< startPosition_type > x)
  {
    this->startPosition_.set (x);
  }

  const occurence::flankN_type& occurence::
  flankN () const
  {
    return this->flankN_.get ();
  }

  occurence::flankN_type& occurence::
  flankN ()
  {
    return this->flankN_.get ();
  }

  void occurence::
  flankN (const flankN_type& x)
  {
    this->flankN_.set (x);
  }

  void occurence::
  flankN (::std::auto_ptr< flankN_type > x)
  {
    this->flankN_.set (x);
  }

  const occurence::flankC_type& occurence::
  flankC () const
  {
    return this->flankC_.get ();
  }

  occurence::flankC_type& occurence::
  flankC ()
  {
    return this->flankC_.get ();
  }

  void occurence::
  flankC (const flankC_type& x)
  {
    this->flankC_.set (x);
  }

  void occurence::
  flankC (::std::auto_ptr< flankC_type > x)
  {
    this->flankC_.set (x);
  }


  // startPosition
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace percolatorInNs
{
  // probability_t
  //

  probability_t::
  probability_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  probability_t::
  probability_t (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  probability_t::
  probability_t (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  probability_t* probability_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class probability_t (*this, f, c);
  }

  // aa_seq_t
  //

  aa_seq_t::
  aa_seq_t ()
  : ::xml_schema::string ()
  {
  }

  aa_seq_t::
  aa_seq_t (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  aa_seq_t::
  aa_seq_t (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  aa_seq_t::
  aa_seq_t (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  aa_seq_t::
  aa_seq_t (const aa_seq_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  aa_seq_t::
  aa_seq_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  aa_seq_t::
  aa_seq_t (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  aa_seq_t::
  aa_seq_t (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  aa_seq_t* aa_seq_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class aa_seq_t (*this, f, c);
  }

  aa_seq_t::
  ~aa_seq_t ()
  {
  }

  // aa_term_t
  //

  aa_term_t::
  aa_term_t ()
  : ::xml_schema::string ()
  {
  }

  aa_term_t::
  aa_term_t (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  aa_term_t::
  aa_term_t (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  aa_term_t::
  aa_term_t (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  aa_term_t::
  aa_term_t (const aa_term_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  aa_term_t::
  aa_term_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  aa_term_t::
  aa_term_t (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  aa_term_t::
  aa_term_t (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  aa_term_t* aa_term_t::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class aa_term_t (*this, f, c);
  }

  aa_term_t::
  ~aa_term_t ()
  {
  }

  // peptideType
  //

  peptideType::
  peptideType (const peptideSequence_type& peptideSequence)
  : ::xml_schema::type (),
    peptideSequence_ (peptideSequence, ::xml_schema::flags (), this),
    modification_ (::xml_schema::flags (), this)
  {
  }

  peptideType::
  peptideType (const peptideType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    peptideSequence_ (x.peptideSequence_, f, this),
    modification_ (x.modification_, f, this)
  {
  }

  peptideType::
  peptideType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    peptideSequence_ (f, this),
    modification_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void peptideType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // peptideSequence
      //
      if (n.name () == "peptideSequence" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< peptideSequence_type > r (
          peptideSequence_traits::create (i, f, this));

        if (!peptideSequence_.present ())
        {
          this->peptideSequence_.set (r);
          continue;
        }
      }

      // modification
      //
      if (n.name () == "modification" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< modification_type > r (
          modification_traits::create (i, f, this));

        this->modification_.push_back (r);
        continue;
      }

      break;
    }

    if (!peptideSequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "peptideSequence",
        "http://per-colator.com/percolator_in/12");
    }
  }

  peptideType* peptideType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class peptideType (*this, f, c);
  }

  peptideType::
  ~peptideType ()
  {
  }

  // modificationType
  //

  modificationType::
  modificationType (const uniMod_type& uniMod,
                    const location_type& location)
  : ::xml_schema::type (),
    uniMod_ (uniMod, ::xml_schema::flags (), this),
    location_ (location, ::xml_schema::flags (), this),
    residues_ (::xml_schema::flags (), this),
    avgMassDelta_ (::xml_schema::flags (), this),
    monoisotopicMassDelta_ (::xml_schema::flags (), this)
  {
  }

  modificationType::
  modificationType (::std::auto_ptr< uniMod_type >& uniMod,
                    const location_type& location)
  : ::xml_schema::type (),
    uniMod_ (uniMod, ::xml_schema::flags (), this),
    location_ (location, ::xml_schema::flags (), this),
    residues_ (::xml_schema::flags (), this),
    avgMassDelta_ (::xml_schema::flags (), this),
    monoisotopicMassDelta_ (::xml_schema::flags (), this)
  {
  }

  modificationType::
  modificationType (const modificationType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    uniMod_ (x.uniMod_, f, this),
    location_ (x.location_, f, this),
    residues_ (x.residues_, f, this),
    avgMassDelta_ (x.avgMassDelta_, f, this),
    monoisotopicMassDelta_ (x.monoisotopicMassDelta_, f, this)
  {
  }

  modificationType::
  modificationType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    uniMod_ (f, this),
    location_ (f, this),
    residues_ (f, this),
    avgMassDelta_ (f, this),
    monoisotopicMassDelta_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void modificationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // uniMod
      //
      if (n.name () == "uniMod" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< uniMod_type > r (
          uniMod_traits::create (i, f, this));

        if (!uniMod_.present ())
        {
          this->uniMod_.set (r);
          continue;
        }
      }

      break;
    }

    if (!uniMod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uniMod",
        "http://per-colator.com/percolator_in/12");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "location" && n.namespace_ ().empty ())
      {
        this->location_.set (location_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "residues" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< residues_type > r (
          residues_traits::create (i, f, this));

        this->residues_.set (r);
        continue;
      }

      if (n.name () == "avgMassDelta" && n.namespace_ ().empty ())
      {
        this->avgMassDelta_.set (avgMassDelta_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "monoisotopicMassDelta" && n.namespace_ ().empty ())
      {
        this->monoisotopicMassDelta_.set (monoisotopicMassDelta_traits::create (i, f, this));
        continue;
      }
    }

    if (!location_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "location",
        "");
    }
  }

  modificationType* modificationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class modificationType (*this, f, c);
  }

  modificationType::
  ~modificationType ()
  {
  }

  // experiment
  //

  experiment::
  experiment (const enzyme_type& enzyme,
              const process_info_type& process_info,
              const featureDescriptions_type& featureDescriptions)
  : ::xml_schema::type (),
    freeTextInformation_ (::xml_schema::flags (), this),
    enzyme_ (enzyme, ::xml_schema::flags (), this),
    calibration_ (::xml_schema::flags (), this),
    process_info_ (process_info, ::xml_schema::flags (), this),
    featureDescriptions_ (featureDescriptions, ::xml_schema::flags (), this),
    fragSpectrumScan_ (::xml_schema::flags (), this)
  {
  }

  experiment::
  experiment (const enzyme_type& enzyme,
              ::std::auto_ptr< process_info_type >& process_info,
              ::std::auto_ptr< featureDescriptions_type >& featureDescriptions)
  : ::xml_schema::type (),
    freeTextInformation_ (::xml_schema::flags (), this),
    enzyme_ (enzyme, ::xml_schema::flags (), this),
    calibration_ (::xml_schema::flags (), this),
    process_info_ (process_info, ::xml_schema::flags (), this),
    featureDescriptions_ (featureDescriptions, ::xml_schema::flags (), this),
    fragSpectrumScan_ (::xml_schema::flags (), this)
  {
  }

  experiment::
  experiment (const experiment& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    freeTextInformation_ (x.freeTextInformation_, f, this),
    enzyme_ (x.enzyme_, f, this),
    calibration_ (x.calibration_, f, this),
    process_info_ (x.process_info_, f, this),
    featureDescriptions_ (x.featureDescriptions_, f, this),
    fragSpectrumScan_ (x.fragSpectrumScan_, f, this)
  {
  }

  experiment::
  experiment (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    freeTextInformation_ (f, this),
    enzyme_ (f, this),
    calibration_ (f, this),
    process_info_ (f, this),
    featureDescriptions_ (f, this),
    fragSpectrumScan_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void experiment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // freeTextInformation
      //
      if (n.name () == "freeTextInformation" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< freeTextInformation_type > r (
          freeTextInformation_traits::create (i, f, this));

        this->freeTextInformation_.push_back (r);
        continue;
      }

      // enzyme
      //
      if (n.name () == "enzyme" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< enzyme_type > r (
          enzyme_traits::create (i, f, this));

        if (!enzyme_.present ())
        {
          this->enzyme_.set (r);
          continue;
        }
      }

      // calibration
      //
      if (n.name () == "calibration" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< calibration_type > r (
          calibration_traits::create (i, f, this));

        if (!this->calibration_)
        {
          this->calibration_.set (r);
          continue;
        }
      }

      // process_info
      //
      if (n.name () == "process_info" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< process_info_type > r (
          process_info_traits::create (i, f, this));

        if (!process_info_.present ())
        {
          this->process_info_.set (r);
          continue;
        }
      }

      // featureDescriptions
      //
      if (n.name () == "featureDescriptions" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< featureDescriptions_type > r (
          featureDescriptions_traits::create (i, f, this));

        if (!featureDescriptions_.present ())
        {
          this->featureDescriptions_.set (r);
          continue;
        }
      }

      // fragSpectrumScan
      //
      if (n.name () == "fragSpectrumScan" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< fragSpectrumScan_type > r (
          fragSpectrumScan_traits::create (i, f, this));

        this->fragSpectrumScan_.push_back (r);
        continue;
      }

      break;
    }

    if (!enzyme_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "enzyme",
        "http://per-colator.com/percolator_in/12");
    }

    if (!process_info_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "process_info",
        "http://per-colator.com/percolator_in/12");
    }

    if (!featureDescriptions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "featureDescriptions",
        "http://per-colator.com/percolator_in/12");
    }
  }

  experiment* experiment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class experiment (*this, f, c);
  }

  experiment::
  ~experiment ()
  {
  }

  // probability_t_member
  //

  probability_t_member::
  probability_t_member (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
  {
  }

  probability_t_member::
  probability_t_member (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
  {
  }

  probability_t_member::
  probability_t_member (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
  {
  }

  probability_t_member* probability_t_member::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class probability_t_member (*this, f, c);
  }

  // probability_t_member1
  //

  probability_t_member1::
  probability_t_member1 (const ::xml_schema::double_& _xsd_double__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
  {
  }

  probability_t_member1::
  probability_t_member1 (const probability_t_member1& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
  {
  }

  probability_t_member1::
  probability_t_member1 (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
  {
  }

  probability_t_member1::
  probability_t_member1 (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
  {
  }

  probability_t_member1::
  probability_t_member1 (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
  {
  }

  probability_t_member1* probability_t_member1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class probability_t_member1 (*this, f, c);
  }

  probability_t_member1::
  ~probability_t_member1 ()
  {
  }

  // uniMod
  //

  uniMod::
  uniMod (const accession_type& accession)
  : ::xml_schema::type (),
    accession_ (accession, ::xml_schema::flags (), this),
    name_ (::xml_schema::flags (), this)
  {
  }

  uniMod::
  uniMod (const uniMod& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    accession_ (x.accession_, f, this),
    name_ (x.name_, f, this)
  {
  }

  uniMod::
  uniMod (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    accession_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void uniMod::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "accession" && n.namespace_ ().empty ())
      {
        this->accession_.set (accession_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!accession_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "accession",
        "");
    }
  }

  uniMod* uniMod::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class uniMod (*this, f, c);
  }

  uniMod::
  ~uniMod ()
  {
  }

  // freeTextInformation
  //

  freeTextInformation::
  freeTextInformation (const name_type& name,
                       const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  freeTextInformation::
  freeTextInformation (const freeTextInformation& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  freeTextInformation::
  freeTextInformation (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void freeTextInformation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  freeTextInformation* freeTextInformation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class freeTextInformation (*this, f, c);
  }

  freeTextInformation::
  ~freeTextInformation ()
  {
  }

  // calibration
  //

  calibration::
  calibration (const massType_type& massType)
  : ::xml_schema::type (),
    calibrationParameter_ (::xml_schema::flags (), this),
    massType_ (massType, ::xml_schema::flags (), this)
  {
  }

  calibration::
  calibration (const calibration& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    calibrationParameter_ (x.calibrationParameter_, f, this),
    massType_ (x.massType_, f, this)
  {
  }

  calibration::
  calibration (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    calibrationParameter_ (f, this),
    massType_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void calibration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // calibrationParameter
      //
      if (n.name () == "calibrationParameter" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< calibrationParameter_type > r (
          calibrationParameter_traits::create (i, f, this));

        this->calibrationParameter_.push_back (r);
        continue;
      }

      // massType
      //
      if (n.name () == "massType" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< massType_type > r (
          massType_traits::create (i, f, this));

        if (!massType_.present ())
        {
          this->massType_.set (r);
          continue;
        }
      }

      break;
    }

    if (!massType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "massType",
        "http://per-colator.com/percolator_in/12");
    }
  }

  calibration* calibration::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class calibration (*this, f, c);
  }

  calibration::
  ~calibration ()
  {
  }

  // process_info
  //

  process_info::
  process_info (const command_line_type& command_line)
  : ::xml_schema::type (),
    command_line_ (command_line, ::xml_schema::flags (), this)
  {
  }

  process_info::
  process_info (const process_info& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    command_line_ (x.command_line_, f, this)
  {
  }

  process_info::
  process_info (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    command_line_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void process_info::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // command_line
      //
      if (n.name () == "command_line" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< command_line_type > r (
          command_line_traits::create (i, f, this));

        if (!command_line_.present ())
        {
          this->command_line_.set (r);
          continue;
        }
      }

      break;
    }

    if (!command_line_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "command_line",
        "http://per-colator.com/percolator_in/12");
    }
  }

  process_info* process_info::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class process_info (*this, f, c);
  }

  process_info::
  ~process_info ()
  {
  }

  // featureDescriptions
  //

  featureDescriptions::
  featureDescriptions ()
  : ::xml_schema::type (),
    featureDescription_ (::xml_schema::flags (), this)
  {
  }

  featureDescriptions::
  featureDescriptions (const featureDescriptions& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    featureDescription_ (x.featureDescription_, f, this)
  {
  }

  featureDescriptions::
  featureDescriptions (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    featureDescription_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void featureDescriptions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // featureDescription
      //
      if (n.name () == "featureDescription" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< featureDescription_type > r (
          featureDescription_traits::create (i, f, this));

        this->featureDescription_.push_back (r);
        continue;
      }

      break;
    }
  }

  featureDescriptions* featureDescriptions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class featureDescriptions (*this, f, c);
  }

  featureDescriptions::
  ~featureDescriptions ()
  {
  }

  // fragSpectrumScan
  //

  fragSpectrumScan::
  fragSpectrumScan (const scanNumber_type& scanNumber)
  : ::xml_schema::type (),
    peptideSpectrumMatch_ (::xml_schema::flags (), this),
    scanNumber_ (scanNumber, ::xml_schema::flags (), this),
    precision_ (::xml_schema::flags (), this),
    experimentalMassToCharge_ (::xml_schema::flags (), this),
    totalIonCurrent_ (::xml_schema::flags (), this)
  {
  }

  fragSpectrumScan::
  fragSpectrumScan (const fragSpectrumScan& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    peptideSpectrumMatch_ (x.peptideSpectrumMatch_, f, this),
    scanNumber_ (x.scanNumber_, f, this),
    precision_ (x.precision_, f, this),
    experimentalMassToCharge_ (x.experimentalMassToCharge_, f, this),
    totalIonCurrent_ (x.totalIonCurrent_, f, this)
  {
  }

  fragSpectrumScan::
  fragSpectrumScan (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    peptideSpectrumMatch_ (f, this),
    scanNumber_ (f, this),
    precision_ (f, this),
    experimentalMassToCharge_ (f, this),
    totalIonCurrent_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void fragSpectrumScan::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // peptideSpectrumMatch
      //
      if (n.name () == "peptideSpectrumMatch" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< peptideSpectrumMatch_type > r (
          peptideSpectrumMatch_traits::create (i, f, this));

        this->peptideSpectrumMatch_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scanNumber" && n.namespace_ ().empty ())
      {
        this->scanNumber_.set (scanNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "precision" && n.namespace_ ().empty ())
      {
        this->precision_.set (precision_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "experimentalMassToCharge" && n.namespace_ ().empty ())
      {
        this->experimentalMassToCharge_.set (experimentalMassToCharge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "totalIonCurrent" && n.namespace_ ().empty ())
      {
        this->totalIonCurrent_.set (totalIonCurrent_traits::create (i, f, this));
        continue;
      }
    }

    if (!scanNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scanNumber",
        "");
    }
  }

  fragSpectrumScan* fragSpectrumScan::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fragSpectrumScan (*this, f, c);
  }

  fragSpectrumScan::
  ~fragSpectrumScan ()
  {
  }

  // calibrationParameter
  //

  calibrationParameter::
  calibrationParameter (const name_type& name,
                        const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  calibrationParameter::
  calibrationParameter (const calibrationParameter& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  calibrationParameter::
  calibrationParameter (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void calibrationParameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  calibrationParameter* calibrationParameter::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class calibrationParameter (*this, f, c);
  }

  calibrationParameter::
  ~calibrationParameter ()
  {
  }

  // massType
  //

  massType::
  massType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (e, f, c)
  {
    _xsd_massType_convert ();
  }

  massType::
  massType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (a, f, c)
  {
    _xsd_massType_convert ();
  }

  massType::
  massType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, e, f, c)
  {
    _xsd_massType_convert ();
  }

  massType* massType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class massType (*this, f, c);
  }

  massType::value massType::
  _xsd_massType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_massType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_massType_indexes_,
                      _xsd_massType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_massType_indexes_ + 2 || _xsd_massType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const massType::
  _xsd_massType_literals_[2] =
  {
    "monoisotopic",
    "average"
  };

  const massType::value massType::
  _xsd_massType_indexes_[2] =
  {
    ::percolatorInNs::massType::average,
    ::percolatorInNs::massType::monoisotopic
  };

  // featureDescription
  //

  featureDescription::
  featureDescription (const name_type& name)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    description_ (::xml_schema::flags (), this)
  {
  }

  featureDescription::
  featureDescription (const featureDescription& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    description_ (x.description_, f, this)
  {
  }

  featureDescription::
  featureDescription (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    description_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void featureDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< description_type > r (
          description_traits::create (i, f, this));

        this->description_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  featureDescription* featureDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class featureDescription (*this, f, c);
  }

  featureDescription::
  ~featureDescription ()
  {
  }

  // peptideSpectrumMatch
  //

  peptideSpectrumMatch::
  peptideSpectrumMatch (const features_type& features,
                        const peptide_type& peptide,
                        const id_type& id,
                        const isDecoy_type& isDecoy,
                        const experimentalMassToCharge_type& experimentalMassToCharge,
                        const calculatedMassToCharge_type& calculatedMassToCharge,
                        const chargeState_type& chargeState)
  : ::xml_schema::type (),
    features_ (features, ::xml_schema::flags (), this),
    peptide_ (peptide, ::xml_schema::flags (), this),
    occurence_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    isDecoy_ (isDecoy, ::xml_schema::flags (), this),
    observedTime_ (::xml_schema::flags (), this),
    experimentalMassToCharge_ (experimentalMassToCharge, ::xml_schema::flags (), this),
    calculatedMassToCharge_ (calculatedMassToCharge, ::xml_schema::flags (), this),
    chargeState_ (chargeState, ::xml_schema::flags (), this)
  {
  }

  peptideSpectrumMatch::
  peptideSpectrumMatch (::std::auto_ptr< features_type >& features,
                        ::std::auto_ptr< peptide_type >& peptide,
                        const id_type& id,
                        const isDecoy_type& isDecoy,
                        const experimentalMassToCharge_type& experimentalMassToCharge,
                        const calculatedMassToCharge_type& calculatedMassToCharge,
                        const chargeState_type& chargeState)
  : ::xml_schema::type (),
    features_ (features, ::xml_schema::flags (), this),
    peptide_ (peptide, ::xml_schema::flags (), this),
    occurence_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    isDecoy_ (isDecoy, ::xml_schema::flags (), this),
    observedTime_ (::xml_schema::flags (), this),
    experimentalMassToCharge_ (experimentalMassToCharge, ::xml_schema::flags (), this),
    calculatedMassToCharge_ (calculatedMassToCharge, ::xml_schema::flags (), this),
    chargeState_ (chargeState, ::xml_schema::flags (), this)
  {
  }

  peptideSpectrumMatch::
  peptideSpectrumMatch (const peptideSpectrumMatch& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    features_ (x.features_, f, this),
    peptide_ (x.peptide_, f, this),
    occurence_ (x.occurence_, f, this),
    id_ (x.id_, f, this),
    isDecoy_ (x.isDecoy_, f, this),
    observedTime_ (x.observedTime_, f, this),
    experimentalMassToCharge_ (x.experimentalMassToCharge_, f, this),
    calculatedMassToCharge_ (x.calculatedMassToCharge_, f, this),
    chargeState_ (x.chargeState_, f, this)
  {
  }

  peptideSpectrumMatch::
  peptideSpectrumMatch (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    features_ (f, this),
    peptide_ (f, this),
    occurence_ (f, this),
    id_ (f, this),
    isDecoy_ (f, this),
    observedTime_ (f, this),
    experimentalMassToCharge_ (f, this),
    calculatedMassToCharge_ (f, this),
    chargeState_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void peptideSpectrumMatch::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // features
      //
      if (n.name () == "features" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< features_type > r (
          features_traits::create (i, f, this));

        if (!features_.present ())
        {
          this->features_.set (r);
          continue;
        }
      }

      // peptide
      //
      if (n.name () == "peptide" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< peptide_type > r (
          peptide_traits::create (i, f, this));

        if (!peptide_.present ())
        {
          this->peptide_.set (r);
          continue;
        }
      }

      // occurence
      //
      if (n.name () == "occurence" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        ::std::auto_ptr< occurence_type > r (
          occurence_traits::create (i, f, this));

        this->occurence_.push_back (r);
        continue;
      }

      break;
    }

    if (!features_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "features",
        "http://per-colator.com/percolator_in/12");
    }

    if (!peptide_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "peptide",
        "http://per-colator.com/percolator_in/12");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "isDecoy" && n.namespace_ ().empty ())
      {
        this->isDecoy_.set (isDecoy_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "observedTime" && n.namespace_ ().empty ())
      {
        this->observedTime_.set (observedTime_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "experimentalMassToCharge" && n.namespace_ ().empty ())
      {
        this->experimentalMassToCharge_.set (experimentalMassToCharge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "calculatedMassToCharge" && n.namespace_ ().empty ())
      {
        this->calculatedMassToCharge_.set (calculatedMassToCharge_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "chargeState" && n.namespace_ ().empty ())
      {
        this->chargeState_.set (chargeState_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!isDecoy_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "isDecoy",
        "");
    }

    if (!experimentalMassToCharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "experimentalMassToCharge",
        "");
    }

    if (!calculatedMassToCharge_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "calculatedMassToCharge",
        "");
    }

    if (!chargeState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "chargeState",
        "");
    }
  }

  peptideSpectrumMatch* peptideSpectrumMatch::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class peptideSpectrumMatch (*this, f, c);
  }

  peptideSpectrumMatch::
  ~peptideSpectrumMatch ()
  {
  }

  // features
  //

  features::
  features ()
  : ::xml_schema::type (),
    feature_ (::xml_schema::flags (), this)
  {
  }

  features::
  features (const features& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    feature_ (x.feature_, f, this)
  {
  }

  features::
  features (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    feature_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void features::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // feature
      //
      if (n.name () == "feature" && n.namespace_ () == "http://per-colator.com/percolator_in/12")
      {
        this->feature_.push_back (feature_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  features* features::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class features (*this, f, c);
  }

  features::
  ~features ()
  {
  }

  // occurence
  //

  occurence::
  occurence (const proteinId_type& proteinId,
             const flankN_type& flankN,
             const flankC_type& flankC)
  : ::xml_schema::type (),
    proteinId_ (proteinId, ::xml_schema::flags (), this),
    startPosition_ (::xml_schema::flags (), this),
    flankN_ (flankN, ::xml_schema::flags (), this),
    flankC_ (flankC, ::xml_schema::flags (), this)
  {
  }

  occurence::
  occurence (const occurence& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    proteinId_ (x.proteinId_, f, this),
    startPosition_ (x.startPosition_, f, this),
    flankN_ (x.flankN_, f, this),
    flankC_ (x.flankC_, f, this)
  {
  }

  occurence::
  occurence (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    proteinId_ (f, this),
    startPosition_ (f, this),
    flankN_ (f, this),
    flankC_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void occurence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "proteinId" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< proteinId_type > r (
          proteinId_traits::create (i, f, this));

        this->proteinId_.set (r);
        continue;
      }

      if (n.name () == "startPosition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< startPosition_type > r (
          startPosition_traits::create (i, f, this));

        this->startPosition_.set (r);
        continue;
      }

      if (n.name () == "flankN" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< flankN_type > r (
          flankN_traits::create (i, f, this));

        this->flankN_.set (r);
        continue;
      }

      if (n.name () == "flankC" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< flankC_type > r (
          flankC_traits::create (i, f, this));

        this->flankC_.set (r);
        continue;
      }
    }

    if (!proteinId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "proteinId",
        "");
    }

    if (!flankN_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "flankN",
        "");
    }

    if (!flankC_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "flankC",
        "");
    }
  }

  occurence* occurence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class occurence (*this, f, c);
  }

  occurence::
  ~occurence ()
  {
  }

  // startPosition
  //

  startPosition::
  startPosition (const ::xml_schema::int_& _xsd_int__base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (_xsd_int__base)
  {
  }

  startPosition::
  startPosition (const startPosition& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  startPosition::
  startPosition (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  startPosition::
  startPosition (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  startPosition::
  startPosition (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  startPosition* startPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class startPosition (*this, f, c);
  }

  startPosition::
  ~startPosition ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace percolatorInNs
{
  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::percolatorInNs::experiment > r (
      ::percolatorInNs::experiment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::percolatorInNs::experiment > r (
      ::percolatorInNs::experiment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::percolatorInNs::experiment > r (
      ::percolatorInNs::experiment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::percolatorInNs::experiment_ (isrc, f, p);
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::percolatorInNs::experiment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::percolatorInNs::experiment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::percolatorInNs::experiment_ (isrc, f, p);
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::percolatorInNs::experiment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::percolatorInNs::experiment_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::percolatorInNs::experiment > r (
      ::percolatorInNs::experiment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::percolatorInNs::experiment > r (
      ::percolatorInNs::experiment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::percolatorInNs::experiment > r (
      ::percolatorInNs::experiment_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::percolatorInNs::experiment > r (
        ::percolatorInNs::experiment_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "experiment" &&
        n.namespace_ () == "http://per-colator.com/percolator_in/12")
    {
      ::std::auto_ptr< ::percolatorInNs::experiment > r (
        ::xsd::cxx::tree::traits< ::percolatorInNs::experiment, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "experiment",
      "http://per-colator.com/percolator_in/12");
  }

  ::std::auto_ptr< ::percolatorInNs::experiment >
  experiment_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "experiment" &&
        n.namespace_ () == "http://per-colator.com/percolator_in/12")
    {
      ::std::auto_ptr< ::percolatorInNs::experiment > r (
        ::xsd::cxx::tree::traits< ::percolatorInNs::experiment, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "experiment",
      "http://per-colator.com/percolator_in/12");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace percolatorInNs
{
  void
  experiment_ (::std::ostream& o,
               const ::percolatorInNs::experiment& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::percolatorInNs::experiment_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  experiment_ (::std::ostream& o,
               const ::percolatorInNs::experiment& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::percolatorInNs::experiment_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  experiment_ (::std::ostream& o,
               const ::percolatorInNs::experiment& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::percolatorInNs::experiment_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  experiment_ (::xercesc::XMLFormatTarget& t,
               const ::percolatorInNs::experiment& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::percolatorInNs::experiment_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  experiment_ (::xercesc::XMLFormatTarget& t,
               const ::percolatorInNs::experiment& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::percolatorInNs::experiment_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  experiment_ (::xercesc::XMLFormatTarget& t,
               const ::percolatorInNs::experiment& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::string& e,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::percolatorInNs::experiment_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  experiment_ (::xercesc::DOMDocument& d,
               const ::percolatorInNs::experiment& s,
               ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "experiment" &&
        n.namespace_ () == "http://per-colator.com/percolator_in/12")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "experiment",
        "http://per-colator.com/percolator_in/12");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  experiment_ (const ::percolatorInNs::experiment& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "experiment",
        "http://per-colator.com/percolator_in/12",
        m, f));

    ::percolatorInNs::experiment_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const probability_t& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const probability_t& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const probability_t& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const aa_seq_t& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const aa_seq_t& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const aa_seq_t& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const aa_term_t& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const aa_term_t& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const aa_term_t& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const peptideType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // peptideSequence
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "peptideSequence",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.peptideSequence ();
    }

    // modification
    //
    for (peptideType::modification_const_iterator
         b (i.modification ().begin ()), n (i.modification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "modification",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const modificationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // uniMod
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "uniMod",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.uniMod ();
    }

    // location
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "location",
          e));

      a << i.location ();
    }

    // residues
    //
    if (i.residues ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "residues",
          e));

      a << *i.residues ();
    }

    // avgMassDelta
    //
    if (i.avgMassDelta ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "avgMassDelta",
          e));

      a << ::xml_schema::as_double(*i.avgMassDelta ());
    }

    // monoisotopicMassDelta
    //
    if (i.monoisotopicMassDelta ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "monoisotopicMassDelta",
          e));

      a << ::xml_schema::as_double(*i.monoisotopicMassDelta ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const experiment& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // freeTextInformation
    //
    for (experiment::freeTextInformation_const_iterator
         b (i.freeTextInformation ().begin ()), n (i.freeTextInformation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "freeTextInformation",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }

    // enzyme
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "enzyme",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.enzyme ();
    }

    // calibration
    //
    if (i.calibration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "calibration",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *i.calibration ();
    }

    // process_info
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "process_info",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.process_info ();
    }

    // featureDescriptions
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "featureDescriptions",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.featureDescriptions ();
    }

    // fragSpectrumScan
    //
    for (experiment::fragSpectrumScan_const_iterator
         b (i.fragSpectrumScan ().begin ()), n (i.fragSpectrumScan ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fragSpectrumScan",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const probability_t_member& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const probability_t_member& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const probability_t_member& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const probability_t_member1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const probability_t_member1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const probability_t_member1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const uniMod& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // accession
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "accession",
          e));

      a << i.accession ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const freeTextInformation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const calibration& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // calibrationParameter
    //
    for (calibration::calibrationParameter_const_iterator
         b (i.calibrationParameter ().begin ()), n (i.calibrationParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "calibrationParameter",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }

    // massType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "massType",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.massType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const process_info& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // command_line
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "command_line",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.command_line ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const featureDescriptions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // featureDescription
    //
    for (featureDescriptions::featureDescription_const_iterator
         b (i.featureDescription ().begin ()), n (i.featureDescription ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "featureDescription",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const fragSpectrumScan& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // peptideSpectrumMatch
    //
    for (fragSpectrumScan::peptideSpectrumMatch_const_iterator
         b (i.peptideSpectrumMatch ().begin ()), n (i.peptideSpectrumMatch ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "peptideSpectrumMatch",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }

    // scanNumber
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scanNumber",
          e));

      a << i.scanNumber ();
    }

    // precision
    //
    if (i.precision ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "precision",
          e));

      a << ::xml_schema::as_double(*i.precision ());
    }

    // experimentalMassToCharge
    //
    if (i.experimentalMassToCharge ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "experimentalMassToCharge",
          e));

      a << ::xml_schema::as_double(*i.experimentalMassToCharge ());
    }

    // totalIonCurrent
    //
    if (i.totalIonCurrent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "totalIonCurrent",
          e));

      a << ::xml_schema::as_double(*i.totalIonCurrent ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const calibrationParameter& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::as_double(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const massType& i)
  {
    e << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const massType& i)
  {
    a << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const massType& i)
  {
    l << static_cast< const ::xml_schema::token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const featureDescription& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // description
    //
    if (i.description ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "description",
          e));

      a << *i.description ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const peptideSpectrumMatch& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // features
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "features",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.features ();
    }

    // peptide
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "peptide",
          "http://per-colator.com/percolator_in/12",
          e));

      s << i.peptide ();
    }

    // occurence
    //
    for (peptideSpectrumMatch::occurence_const_iterator
         b (i.occurence ().begin ()), n (i.occurence ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "occurence",
          "http://per-colator.com/percolator_in/12",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // isDecoy
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isDecoy",
          e));

      a << i.isDecoy ();
    }

    // observedTime
    //
    if (i.observedTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "observedTime",
          e));

      a << ::xml_schema::as_double(*i.observedTime ());
    }

    // experimentalMassToCharge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "experimentalMassToCharge",
          e));

      a << ::xml_schema::as_double(i.experimentalMassToCharge ());
    }

    // calculatedMassToCharge
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "calculatedMassToCharge",
          e));

      a << ::xml_schema::as_double(i.calculatedMassToCharge ());
    }

    // chargeState
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "chargeState",
          e));

      a << i.chargeState ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const features& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // feature
    //
    for (features::feature_const_iterator
         b (i.feature ().begin ()), n (i.feature ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "feature",
          "http://per-colator.com/percolator_in/12",
          e));

      s << ::xml_schema::as_double (*b);
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const occurence& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // proteinId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "proteinId",
          e));

      a << i.proteinId ();
    }

    // startPosition
    //
    if (i.startPosition ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "startPosition",
          e));

      a << *i.startPosition ();
    }

    // flankN
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "flankN",
          e));

      a << i.flankN ();
    }

    // flankC
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "flankC",
          e));

      a << i.flankC ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const startPosition& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const startPosition& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const startPosition& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
  }
}

namespace percolatorInNs
{
  probability_t::
  probability_t (::xml_schema::istream< XDR >& s,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, f, c)
  {
  }

  aa_seq_t::
  aa_seq_t (::xml_schema::istream< XDR >& s,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, f, c)
  {
  }

  aa_term_t::
  aa_term_t (::xml_schema::istream< XDR >& s,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, f, c)
  {
  }

  peptideType::
  peptideType (::xml_schema::istream< XDR >& s,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    peptideSequence_ (f, this),
    modification_ (f, this)
  {
    this->parse (s, f);
  }

  void peptideType::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< peptideSequence_type > r (new peptideSequence_type (s, f, this));
      this->peptideSequence_.set (r);
    }

    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        modification_sequence& c (this->modification_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< modification_type > r (new modification_type (s, f, this));
          c.push_back (r);
        }
      }
    }
  }

  modificationType::
  modificationType (::xml_schema::istream< XDR >& s,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    uniMod_ (f, this),
    location_ (f, this),
    residues_ (f, this),
    avgMassDelta_ (f, this),
    monoisotopicMassDelta_ (f, this)
  {
    this->parse (s, f);
  }

  void modificationType::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< uniMod_type > r (new uniMod_type (s, f, this));
      this->uniMod_.set (r);
    }

    {
      location_type r;
      s >> r;
      this->location_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        ::std::auto_ptr< residues_type > r (new residues_type (s, f, this));
        this->residues_.set (r);
      }
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        avgMassDelta_type r;
        s >> r;
        this->avgMassDelta_.set (r);
      }
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        monoisotopicMassDelta_type r;
        s >> r;
        this->monoisotopicMassDelta_.set (r);
      }
    }
  }

  experiment::
  experiment (::xml_schema::istream< XDR >& s,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    freeTextInformation_ (f, this),
    enzyme_ (f, this),
    calibration_ (f, this),
    process_info_ (f, this),
    featureDescriptions_ (f, this),
    fragSpectrumScan_ (f, this)
  {
    this->parse (s, f);
  }

  void experiment::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        freeTextInformation_sequence& c (this->freeTextInformation_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< freeTextInformation_type > r (new freeTextInformation_type (s, f, this));
          c.push_back (r);
        }
      }
    }

    {
      ::std::auto_ptr< enzyme_type > r (new enzyme_type (s, f, this));
      this->enzyme_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        ::std::auto_ptr< calibration_type > r (new calibration_type (s, f, this));
        this->calibration_.set (r);
      }
    }

    {
      ::std::auto_ptr< process_info_type > r (new process_info_type (s, f, this));
      this->process_info_.set (r);
    }

    {
      ::std::auto_ptr< featureDescriptions_type > r (new featureDescriptions_type (s, f, this));
      this->featureDescriptions_.set (r);
    }

    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        fragSpectrumScan_sequence& c (this->fragSpectrumScan_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< fragSpectrumScan_type > r (new fragSpectrumScan_type (s, f, this));
          c.push_back (r);
        }
      }
    }
  }

  probability_t_member::
  probability_t_member (::xml_schema::istream< XDR >& s,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c)
  {
  }

  probability_t_member1::
  probability_t_member1 (::xml_schema::istream< XDR >& s,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, f, c)
  {
  }

  uniMod::
  uniMod (::xml_schema::istream< XDR >& s,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    accession_ (f, this),
    name_ (f, this)
  {
    this->parse (s, f);
  }

  void uniMod::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      accession_type r;
      s >> r;
      this->accession_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        ::std::auto_ptr< name_type > r (new name_type (s, f, this));
        this->name_.set (r);
      }
    }
  }

  freeTextInformation::
  freeTextInformation (::xml_schema::istream< XDR >& s,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    name_ (f, this),
    value_ (f, this)
  {
    this->parse (s, f);
  }

  void freeTextInformation::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< name_type > r (new name_type (s, f, this));
      this->name_.set (r);
    }

    {
      ::std::auto_ptr< value_type > r (new value_type (s, f, this));
      this->value_.set (r);
    }
  }

  calibration::
  calibration (::xml_schema::istream< XDR >& s,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    calibrationParameter_ (f, this),
    massType_ (f, this)
  {
    this->parse (s, f);
  }

  void calibration::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        calibrationParameter_sequence& c (this->calibrationParameter_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< calibrationParameter_type > r (new calibrationParameter_type (s, f, this));
          c.push_back (r);
        }
      }
    }

    {
      ::std::auto_ptr< massType_type > r (new massType_type (s, f, this));
      this->massType_.set (r);
    }
  }

  process_info::
  process_info (::xml_schema::istream< XDR >& s,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    command_line_ (f, this)
  {
    this->parse (s, f);
  }

  void process_info::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< command_line_type > r (new command_line_type (s, f, this));
      this->command_line_.set (r);
    }
  }

  featureDescriptions::
  featureDescriptions (::xml_schema::istream< XDR >& s,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    featureDescription_ (f, this)
  {
    this->parse (s, f);
  }

  void featureDescriptions::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        featureDescription_sequence& c (this->featureDescription_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< featureDescription_type > r (new featureDescription_type (s, f, this));
          c.push_back (r);
        }
      }
    }
  }

  fragSpectrumScan::
  fragSpectrumScan (::xml_schema::istream< XDR >& s,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    peptideSpectrumMatch_ (f, this),
    scanNumber_ (f, this),
    precision_ (f, this),
    experimentalMassToCharge_ (f, this),
    totalIonCurrent_ (f, this)
  {
    this->parse (s, f);
  }

  void fragSpectrumScan::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        peptideSpectrumMatch_sequence& c (this->peptideSpectrumMatch_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< peptideSpectrumMatch_type > r (new peptideSpectrumMatch_type (s, f, this));
          c.push_back (r);
        }
      }
    }

    {
      scanNumber_type r;
      s >> r;
      this->scanNumber_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        precision_type r;
        s >> r;
        this->precision_.set (r);
      }
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        experimentalMassToCharge_type r;
        s >> r;
        this->experimentalMassToCharge_.set (r);
      }
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        totalIonCurrent_type r;
        s >> r;
        this->totalIonCurrent_.set (r);
      }
    }
  }

  calibrationParameter::
  calibrationParameter (::xml_schema::istream< XDR >& s,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    name_ (f, this),
    value_ (f, this)
  {
    this->parse (s, f);
  }

  void calibrationParameter::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< name_type > r (new name_type (s, f, this));
      this->name_.set (r);
    }

    {
      value_type r;
      s >> r;
      this->value_.set (r);
    }
  }

  massType::
  massType (::xml_schema::istream< XDR >& s,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::token (s, f, c)
  {
    _xsd_massType_convert ();
  }

  featureDescription::
  featureDescription (::xml_schema::istream< XDR >& s,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    name_ (f, this),
    description_ (f, this)
  {
    this->parse (s, f);
  }

  void featureDescription::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< name_type > r (new name_type (s, f, this));
      this->name_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        ::std::auto_ptr< description_type > r (new description_type (s, f, this));
        this->description_.set (r);
      }
    }
  }

  peptideSpectrumMatch::
  peptideSpectrumMatch (::xml_schema::istream< XDR >& s,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    features_ (f, this),
    peptide_ (f, this),
    occurence_ (f, this),
    id_ (f, this),
    isDecoy_ (f, this),
    observedTime_ (f, this),
    experimentalMassToCharge_ (f, this),
    calculatedMassToCharge_ (f, this),
    chargeState_ (f, this)
  {
    this->parse (s, f);
  }

  void peptideSpectrumMatch::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< features_type > r (new features_type (s, f, this));
      this->features_.set (r);
    }

    {
      ::std::auto_ptr< peptide_type > r (new peptide_type (s, f, this));
      this->peptide_.set (r);
    }

    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        occurence_sequence& c (this->occurence_);
        c.reserve (n);
        while (n--)
        {
          ::std::auto_ptr< occurence_type > r (new occurence_type (s, f, this));
          c.push_back (r);
        }
      }
    }

    {
      ::std::auto_ptr< id_type > r (new id_type (s, f, this));
      this->id_.set (r);
    }

    {
      isDecoy_type r;
      s >> r;
      this->isDecoy_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        observedTime_type r;
        s >> r;
        this->observedTime_.set (r);
      }
    }

    {
      experimentalMassToCharge_type r;
      s >> r;
      this->experimentalMassToCharge_.set (r);
    }

    {
      calculatedMassToCharge_type r;
      s >> r;
      this->calculatedMassToCharge_.set (r);
    }

    {
      chargeState_type r;
      s >> r;
      this->chargeState_.set (r);
    }
  }

  features::
  features (::xml_schema::istream< XDR >& s,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    feature_ (f, this)
  {
    this->parse (s, f);
  }

  void features::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::size_t n;
      ::xsd::cxx::tree::istream_common::as_size< ::std::size_t > as (n);
      s >> as;
      if (n > 0)
      {
        feature_sequence& c (this->feature_);
        c.reserve (n);
        while (n--)
        {
          feature_type r;
          s >> r;
          c.push_back (r);
        }
      }
    }
  }

  occurence::
  occurence (::xml_schema::istream< XDR >& s,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (s, f, c),
    proteinId_ (f, this),
    startPosition_ (f, this),
    flankN_ (f, this),
    flankC_ (f, this)
  {
    this->parse (s, f);
  }

  void occurence::
  parse (::xml_schema::istream< XDR >& s,
         ::xml_schema::flags f)
  {
    {
      ::std::auto_ptr< proteinId_type > r (new proteinId_type (s, f, this));
      this->proteinId_.set (r);
    }

    {
      bool p;
      s >> p;
      if (p)
      {
        ::std::auto_ptr< startPosition_type > r (new startPosition_type (s, f, this));
        this->startPosition_.set (r);
      }
    }

    {
      ::std::auto_ptr< flankN_type > r (new flankN_type (s, f, this));
      this->flankN_.set (r);
    }

    {
      ::std::auto_ptr< flankC_type > r (new flankC_type (s, f, this));
      this->flankC_.set (r);
    }
  }

  startPosition::
  startPosition (::xml_schema::istream< XDR >& s,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, f, c)
  {
  }
}

namespace percolatorInNs
{
  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const probability_t& x)
  {
    return s << static_cast< const ::xml_schema::string& > (x);
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const aa_seq_t& x)
  {
    s << static_cast< const ::xml_schema::string& > (x);
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const aa_term_t& x)
  {
    s << static_cast< const ::xml_schema::string& > (x);
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const peptideType& x)
  {
    s << x.peptideSequence ();
    {
      const peptideType::modification_sequence& c (x.modification ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (peptideType::modification_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const modificationType& x)
  {
    s << x.uniMod ();
    s << x.location ();
    {
      bool p (x.residues ());
      s << p;
      if (p)
        s << *x.residues ();
    }

    {
      bool p (x.avgMassDelta ());
      s << p;
      if (p)
        s << *x.avgMassDelta ();
    }

    {
      bool p (x.monoisotopicMassDelta ());
      s << p;
      if (p)
        s << *x.monoisotopicMassDelta ();
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const experiment& x)
  {
    {
      const experiment::freeTextInformation_sequence& c (x.freeTextInformation ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (experiment::freeTextInformation_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    s << x.enzyme ();
    {
      bool p (x.calibration ());
      s << p;
      if (p)
        s << *x.calibration ();
    }

    s << x.process_info ();
    s << x.featureDescriptions ();
    {
      const experiment::fragSpectrumScan_sequence& c (x.fragSpectrumScan ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (experiment::fragSpectrumScan_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const probability_t_member& x)
  {
    return s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const probability_t_member1& x)
  {
    s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (x);
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const uniMod& x)
  {
    s << x.accession ();
    {
      bool p (x.name ());
      s << p;
      if (p)
        s << *x.name ();
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const freeTextInformation& x)
  {
    s << x.name ();
    s << x.value ();
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const calibration& x)
  {
    {
      const calibration::calibrationParameter_sequence& c (x.calibrationParameter ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (calibration::calibrationParameter_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    s << x.massType ();
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const process_info& x)
  {
    s << x.command_line ();
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const featureDescriptions& x)
  {
    {
      const featureDescriptions::featureDescription_sequence& c (x.featureDescription ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (featureDescriptions::featureDescription_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const fragSpectrumScan& x)
  {
    {
      const fragSpectrumScan::peptideSpectrumMatch_sequence& c (x.peptideSpectrumMatch ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (fragSpectrumScan::peptideSpectrumMatch_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    s << x.scanNumber ();
    {
      bool p (x.precision ());
      s << p;
      if (p)
        s << *x.precision ();
    }

    {
      bool p (x.experimentalMassToCharge ());
      s << p;
      if (p)
        s << *x.experimentalMassToCharge ();
    }

    {
      bool p (x.totalIonCurrent ());
      s << p;
      if (p)
        s << *x.totalIonCurrent ();
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const calibrationParameter& x)
  {
    s << x.name ();
    s << x.value ();
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const massType& x)
  {
    return s << static_cast< const ::xml_schema::token& > (x);
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const featureDescription& x)
  {
    s << x.name ();
    {
      bool p (x.description ());
      s << p;
      if (p)
        s << *x.description ();
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const peptideSpectrumMatch& x)
  {
    s << x.features ();
    s << x.peptide ();
    {
      const peptideSpectrumMatch::occurence_sequence& c (x.occurence ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (peptideSpectrumMatch::occurence_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    s << x.id ();
    s << x.isDecoy ();
    {
      bool p (x.observedTime ());
      s << p;
      if (p)
        s << *x.observedTime ();
    }

    s << x.experimentalMassToCharge ();
    s << x.calculatedMassToCharge ();
    s << x.chargeState ();
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const features& x)
  {
    {
      const features::feature_sequence& c (x.feature ());
      s << ::xsd::cxx::tree::ostream_common::as_size< ::std::size_t > (c.size ());
      for (features::feature_const_iterator
           i (c.begin ()), e (c.end ());
           i != e; ++i)
      {
        s << *i;
      }
    }

    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const occurence& x)
  {
    s << x.proteinId ();
    {
      bool p (x.startPosition ());
      s << p;
      if (p)
        s << *x.startPosition ();
    }

    s << x.flankN ();
    s << x.flankC ();
    return s;
  }

  ::xsd::cxx::tree::ostream< XDR >&
  operator<< (::xsd::cxx::tree::ostream< XDR >& s,
              const startPosition& x)
  {
    s << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (x);
    return s;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

