\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{algpseudocode}
\usepackage{algorithm}

\begin{document}


\begin{algorithm}
\caption{{\bf Searching with Modifications} Inputs: (1) a charged
  spectrum S containing a mass and a list of peaks, (2) a set Q of
  sequences each containing a mass and an ordered list of amino acids,
  (3) a set M of peptide modifications, (4) the number N of PSMs to
  output per spectrum. Outputs: a set R of PSMs.  Each PSM contains a
  peptide sequence (q) and two scores (x, sp).
  \label{algorithm:search}}

\begin{algorithmic}[1]
\Procedure{SearchOneSpectrum}{S, Q, M, N}

\State R $\gets$ []
\Comment Initialize an empty set of results.

\For{i $\gets$ 1 ... $|$M$|$}
   \State Qs $\gets$ selectPeptidesInMassRange(S.mass, M[i], Q)
   \Comment Algorithm~\ref{algorithm:select}
   
   \For{j $\gets$ 1 ... $|$Qs$|$}
     \State r $\gets$ newPsm(Qs[j])
     \Comment Create new PSM and set sequence.
     \State r.sp $\gets$ scorePeptideSp(r.q, S.peaks)
     \Comment Set Sp score for PSM.
     \State R += r
     \Comment Add PSM to set of results.
   \EndFor

   \State R $\gets$ sortBySp(R)
   \State R $\gets$ truncateTopN(R, 500)
   \Comment Keep only best-scoring PSMs for xcorr scoring.

   \For{j $\gets$ 1 ... $|$R$|$}
     \State R[j].x $\gets$ scorePeptideXcorr(R[j].q, S.peaks)
   \EndFor

   \State R $\gets$ sortByXcorr(R)
   \State R $\gets$ truncateTopN(R, N)
   \Comment Keep only N of the best PSMs.

\EndFor

\State \Return{R}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Inputs: the target mass (m), a peptide modification (Mx),
  and a set of possible sequences (Q).  Output: a set of modified
  peptides in the specified mass range.
  \label{algorithm:select}}

\begin{algorithmic}[1]
\Procedure{selectPeptidesInMassRange}{m, Mx, Q}
  \State Qu $\gets$ selectUnmodifiedPeptides(m - Mx.mass, Q)
   
  \State Qm $\gets$ []
  \Comment Initialize set of modified peptides.

  \For{i $\gets$ 1 ... n}
    \If{isModifiable(Qu[i], Mx)}
      \State Qm += generateAllModifiedForms(Qu[i], Mx)
      \Comment Algorithm~\ref{algorithm:generate}
    \EndIf
  \EndFor

  \State \Return{Qm}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{{\bf Modifying a Peptide Sequence} Inputs: (1) a sequence
  containing an ordered list of amino acids (q), (2) a peptide
  modification (m).  The peptide modification contains a collection of 
  amino acid modifications.  Each amino acid modification, a\_i for i
  in 1 to 11 has a count associated with it, count\_a\_i.  Outputs: a
  set of sequences in which the residues have had modifications added
  to them. 
  \label{algorithm:generate}}

\begin{algorithmic}[1]
\Procedure{generateAllModifiedForms}{q, m}

  \State Q $\gets$ [q]
  \Comment Initialize list with the unmodified sequence.

  \For{i $\gets$ 1 ... 11}
  \Comment Apply each modification to the list of sequences.
    \For{i $\gets$ 1 ... count\_a\_i}
    \Comment Apply a\_i count\_a\_i times 
      \For{j $\gets$ 1 ... $|$Q$|$ }
      \Comment Apply to each sequence
        \State Q += applyModToSequence(a\_i, Q[j], j)
        \Comment Algorithm~\ref{algorithm:apply}
      \EndFor
    \EndFor
  \EndFor

  \State \Return{Q}

\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{{\bf Modifying one Residue of a Peptide Sequence} Inputs: (1)
  a peptide sequence q, which is an ordered list of amino acids, each of which
  may be modified, (2) an amino acid modification a,  (3) the number
  of residues already modified by a to skip before applying a
  (n). Outputs: a set of sequences in which one residue has been
  modified by a.
  \label{algorithm:apply}} 
\begin{algorithmic}[1]
\Procedure{applyModToSequence}{q, a, n}

  \State Q $\gets$ []
  \Comment Initialize list of modified sequences

  \For{i $\gets$ 1 ... $|$q$|$}
  \Comment Skip over the first n residues modified by a
    \If{ isModified(q[i], a) }
      \State n $\gets$ n - 1
    \EndIf
    \If{ n == 0 }
      \State startIdx $\gets$ i
    \EndIf
  \EndFor

  \For{j $\gets$ startIdx ... $|$q$|$}
  \Comment Try to modify each of the remaining residues
    \If{ isAaModifiable( q[j], a) }
      \State Q += createModifiedCopy(q, j, a)
      \Comment Create a copy of q and modify q[j]
    \EndIf
  \EndFor

  \State \Return {Q}

\EndProcedure
\end{algorithmic}
\end{algorithm}



\end{document}
