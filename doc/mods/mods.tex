\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{algpseudocode}
\usepackage{algorithm}

\begin{document}


\begin{algorithm}
\caption{{\bf Searching with Modifications} Inputs: (1) a charged
  spectrum S containing a mass and a list of peaks, (2) a set Q of
  sequences each containing a mass and an ordered list of amino acids,
  (3) a set M of peptide modifications, (4) the number N of PSMs to
  output per spectrum. Outputs: a set R of PSMs.  Each PSM contains a
  peptide sequence (q) and two scores (x, sp).
  \label{algorithm:search}}

\begin{algorithmic}[1]
\Procedure{SearchOneSpectrum}{S, Q, M, N}

\State R $\gets$ []
\Comment Initialize an empty set of results.

\For{i $\gets$ 1 ... $|$M$|$}
   \State Qs $\gets$ selectPeptidesInMassRange(S.mass, M[i], Q)
   \Comment Algorithm~\ref{algorithm:select}
   
   \For{j $\gets$ 1 ... $|$Qs$|$}
     \State r $\gets$ newPsm(Qs[j])
     \Comment Create new PSM and set sequence.
     \State r.sp $\gets$ scorePeptideSp(r.q, S.peaks)
     \Comment Set Sp score for PSM.
     \State R += r
     \Comment Add PSM to set of results.
   \EndFor

   \State R $\gets$ sortBySp(R)
   \State R $\gets$ truncateTopN(R, 500)
   \Comment Keep only best-scoring PSMs for xcorr scoring.

   \For{j $\gets$ 1 ... $|$R$|$}
     \State R[j].x $\gets$ scorePeptideXcorr(R[j].q, S.peaks)
   \EndFor

   \State R $\gets$ sortByXcorr(R)
   \State R $\gets$ truncateTopN(R, N)
   \Comment Keep only N of the best PSMs.

\EndFor

\State \Return{R}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Inputs: the target mass (m), a peptide modification (Mx),
  and a set of possible sequences (Q).  Output: a set of modified
  peptides in the specified mass range.
  \label{algorithm:select}}

\begin{algorithmic}[1]
\Procedure{selectPeptidesInMassRange}{m, Mx, Q}
  \State Qu $\gets$ selectUnmodifiedPeptides(m - Mx.mass, Q)
   
  \State Qm $\gets$ []
  \Comment Initialize set of modified peptides.

  \For{i $\gets$ 1 ... $|$Qu$|$}
    \If{isModifiable(Qu[i], Mx)}
      \State Qm += generateAllModifiedForms(Qu[i], Mx)
      \Comment Algorithm~\ref{algorithm:generate}
    \EndIf
  \EndFor

  \State \Return{Qm}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{{\bf Modifying a Peptide Sequence} Inputs: (1) a sequence
  containing an ordered list of amino acids (q), (2) a peptide
  modification (M).  The peptide modification is a list of tuples, each
  with three parts: a unique mass shift (M[i].deltaMass), a count of
  how many of those shifts will be applied to the sequence
  (M[i].count), and a set of amino acids to which this mass shift can
  be applied (M[i].aas).  For example, a peptide mod with 
  M[0].count = 2 will apply a mass shift of M[0].deltaMass to two
  different amino acids in the sequence, those amino acids belonging
  to the set M[i].aas.  Outputs: a set of sequences in which the
  residues have had modifications added to them. 
  \label{algorithm:generate}}

\begin{algorithmic}[1]
\Procedure{generateAllModifiedForms}{q, M}

  \State Q $\gets$ [q]
  \Comment Initialize list with the unmodified sequence.

  \For{i $\gets$ 1 ... $|$M$|$}
  \Comment Apply each modification to the list of sequences.
    \For{i $\gets$ 1 ... M[i].count}
    \Comment Apply M[i].delta mass M.[i]count times 
      \For{j $\gets$ 1 ... $|$Q$|$ }
      \Comment Apply to each sequence
        \State Q += applyModToSequence(M[i].deltaMass, M[i].aas, Q[j],
        j-1)
        \Comment Algorithm~\ref{algorithm:apply}
      \EndFor
    \EndFor
  \EndFor

  \State \Return{Q}

\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{{\bf Modifying one Residue of a Peptide Sequence} Inputs: (1)
  the mass shift to apply (m), (2) the set of amino acids to which
  the shift can be applied (A), (3) a peptide sequence q, which is an
  ordered list of amino acids, (4) the number of residues in the
  sequence already modified by the mass shift to skip (n). Outputs: a
  set of sequences in which one residue has been modified. 
  \label{algorithm:apply}} 
\begin{algorithmic}[1]
\Procedure{applyModToSequence}{m, A, q, n}

  \State Q $\gets$ []
  \Comment Initialize list of modified sequences.

  \For{i $\gets$ 1 ... $|$q$|$}
  \Comment Skip over the first n residues already modified.
    \If{ isModified(q[i], m) }
      \State n $\gets$ n - 1
    \EndIf
    \If{ n == 0 }
      \State startIdx $\gets$ i
    \EndIf
  \EndFor

  \For{j $\gets$ startIdx ... $|$q$|$}
  \Comment Try to modify each of the remaining residues
    \If{ q[j] is a member of set A }
    \Comment If the residue can be modified.
      \State Q += createModifiedCopy(q, j, m)
      \Comment Create a copy of q and modify q[j].
    \EndIf
  \EndFor

  \State \Return {Q}

\EndProcedure
\end{algorithmic}
\end{algorithm}



\end{document}
